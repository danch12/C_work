Thought it would be cool to create functions- allowing for functions to take arguments as well. Cant do recursion properly until we do flow control but may try to implement in the future.

Basic idea is that running a function should be almost the same as running the main code because the main code is pretty much a function in itself. 

Also had a look at how cython does their objects and stuff for a bit of inspiration but stripped the things back quite a lot as it seemed a bit overkill - https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/



To be able to handle positional arguments because we know there's a max of 26 variables that could be arguments when we set the function we can record which position relates to which variable and then when running the function once you get everything set up its pretty much just running a instruction list.

Used a hash map for holding the functions as wanted to use real identifiers for the function names - adds to clarity. Also since we have pretty much all the code made already from the last project it seemed like a good proof of concept to use a version of it. 

Grammar for functions

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC>

<SETFUNC> := "SETFUNC" <FUNCVAR> "{" <ARGSSET> "{" <INSTRUCTLIST>

<ARGSSET> := <VAR><ARGSSET> | "}"

<RUNFUNC> := <FUNCVAR> "{" <ARGRUN>

<ARGRUN> := <VARNUM><ARGRUN> | "}"

<FUNCVAR> := Î£ n=50{a-z}

For FUNCVAR it can be any combination of lowercase letters up to a length of 50, sorry I couldn't format it properly. Thought it would be a good idea to have them lowercase so they wouldn't interfere with any reserved words.

Additionally in the word struct for the extension I have added more features - added a pointer to parent that allows the function to use functions defined in the "main" bit of code. Good thing about doing it this way is it sort of starts to build in scope as it will check for local functions first then go to main functions. This also means we can define functions within functions within functions etc - not that you would usually want to but I quite like having the option. If I have time I want to be able to build recursive functions - first I want to do control flow though.


Thought control flow would be another thing that comes in handy when coding. Maybe having double brackets around a statement could be useful - bit hackey though. Start simple and just have three comparators and if we have time then build it up. Additionally we could eventually have reverse polish comparisons but for now lets stick to varnums. Using the ANSI C grammar for inspiration - https://www.lysator.liu.se/c/ANSI-C-grammar-y.html .

Important thing to consider is that even if we dont execute statements we still want to check for syntax errors. Also not sure why I do { <INSTRUCTLIST> rather than <MAIN> but it says so in the real formal grammar as well. Must be a reason for it.

Formal grammar - 

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <FLOWSTATE>

<FLOWSTATE> := "IF" <EXPRESSION>  "{" <INSTRUCTLIST> | 
		"IF" <EXPRESSION>  "{" <INSTRUCTLIST> "ELSE" "{" <INSTRUCTLIST>

<COMPARATOR> := "==" "<" ">" 

<EXPRESSION> := <VARNUM> <COMPARATOR> <VARNUM>



