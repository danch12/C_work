Thought it would be cool to create functions- allowing for functions to take arguments as well. Cant do recursion properly until we do flow control but may try to implement in the future.

Basic idea is that running a function should be almost the same as running the main code because the main code is pretty much a function in itself. 

Also had a look at how cython does their objects and stuff for a bit of inspiration but stripped the things back quite a lot as it seemed a bit overkill - https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/



To be able to handle positional arguments because we know there's a max of 26 variables that could be arguments when we set the function we can record which position relates to which variable and then when running the function once you get everything set up its pretty much just running a instruction list.

Used a hash map for holding the functions as wanted to use real identifiers for the function names - adds to clarity. Also since we have pretty much all the code made already from the last project it seemed like a good proof of concept to use a version of it. 

Grammar for functions

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <RETURN> 

<SETFUNC> := "SETFUNC" <FUNCVAR> "{" <ARGSSET> "{" <INSTRUCTLIST>

<VARNUM> := number| <VAR> | <RUNFUNC>

<RETURN> := "RETURN" <VARNUM>

<ARGSSET> := <VAR><ARGSSET> | "}"

<RUNFUNC> := <FUNCVAR> "{" <ARGRUN>

<ARGRUN> := <VARNUM><ARGRUN> | "}"

<FUNCVAR> := Î£ n=50{a-z}

For FUNCVAR it can be any combination of lowercase letters up to a length of 50, sorry I didn't know how to say it properly with a formal grammar. Thought it would be a good idea to have them lowercase so they wouldn't interfere with any reserved words.

Additionally in the word struct for the extension I have added more features - added a pointer to parent that allows the function to use functions defined in the "main" bit of code. Good thing about doing it this way is it sort of starts to build in scope as it will check for local functions first then go to main functions. This also means we can define functions within functions within functions etc - not that you would usually want to but I quite like having the option. 

When I run the function I create a deep copy of the function with its arguments then just run it like it was the main bit of the code- this means that I can run as many copies of the function as I want- therefore allowing for recursion.

Thought control flow would be another thing that comes in handy when coding. At the moment we will just use varnums but we could eventually have reverse polish comparisons. Using the ANSI C grammar for inspiration - https://www.lysator.liu.se/c/ANSI-C-grammar-y.html .

Important thing to consider is that even if we don't execute statements we still want to check for syntax errors.

Formal grammar - 

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <FLOWSTATE>

<FLOWSTATE> := "IF" <EXPRESSION>  "{" <INSTRUCTLIST> | 
		"IF" <EXPRESSION>  "{" <INSTRUCTLIST> "ELSE" "{" <INSTRUCTLIST>

<COMPARATOR> := "==" "<" ">" ">=" "<=" 

<EXPRESSION> := <VARNUM> <COMPARATOR> <VARNUM>



Now lets do arrays - reckon this would be fun. Eventually think it would be cool to read in files or something into them. Think then it would be quite useful. Thinking about what ADT would be best to implement it. Would seem like if we didn't want to worry about setting max sizes and stuff then a reallocing array could be cool - although maybe for flexibility a linked list could be best as it allows for easier removal and insertion within the array? Been looking at how lisp does its lists (https://softwareengineering.stackexchange.com/questions/91121/lisp-benefits-of-lists-as-code-over-arrays-as-code and http://www.eecs.qmul.ac.uk/~mmh/ADSOOF/linkedlists/Lecture9.pdf) for some inspiration as they use linked lists to implement arrays but probably will do stuff quite differently as I'm not going to need that much functionality and the syntax is a bit weird. To be honest I doubt that im going to be creating massive arrays so I guess it doesn't matter too much about the implementation.
Also tempted to make arrays global - means that we dont have to worry about returning arrays because that would be a whole other kettle of fish. 


 And then to store the various arrays we could use a hash map again. 
Formal Grammar -

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <FLOWSTATE> | <INITARRAY> | <APPEND> | <REMOVEVAL> | <CHANGEVAL> | <FILETOARRAY> 

<INITARRAY> := "INITARR" <ARRAYIDENTIFIER> 

<APPEND>  :=  <ARRAYIDENTIFIER> "APPEND" <POLISH>


<CHANGEVAL> :=  <ARRAYIDENTIFIER> "[" <VARNUM> "]" ":=" <POLISH>

<REMOVEVAL> := "DEL" <ARRAYIDENTIFIER> "[" <VARNUM> "]"

<ACCESSVAL> :=  <ARRAYIDENTIFIER> "[" <VARNUM> "]"

<VARNUM> := number| <VAR> | <RUNFUNC> | <ACCESSVAL> | <LEN>

<ARRAYIDENTIFIER> := starts with a_ then any set of lower case letters with 50 max total letters - eg a_myarr - this means that technically a_ is also valid

For accessing the arrays the VARNUM has to be positive and not a decimal. This is tested at the interpreting stage and not parsing stage so sometimes will slip through the cracks if for example its in a loop that has not executed. Would have liked to do it at parsing stage but cant tell what the return value of a function would be without actually running the function for instance.


<FILETOARRAY> := "LOAD" <ARRAYIDENTIFIER> filepath 

Filepath is the path from the executable file to the file you want to read in -was going to make it absolute but that would make it hard to move testing to other computers etc. 
Because we do not know what length arrays this could result in we need another instruction as well for it to be useful.

<LEN> "LEN" <ARRAYIDENTIFIER>





