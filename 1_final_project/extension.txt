Thought it would be cool to create functions- allowing for functions to take arguments and return stuff as well. 
Basic idea is that running a function should be almost the same as running the main code because the main code is pretty much a function in itself. 

Also had a look at how cython does their functions and stuff for a bit of inspiration but stripped the things back a lot/changed things as it seemed a bit overkill - https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/



To be able to handle positional arguments because we know there's a max of 26 variables that could be arguments so when we set the function we can record which position relates to which variable. EG if the first argument is C we record a 2 in the var position array so when it comes to running the function we can translate the args to running the function. and then when actually running the function once you get everything set up its pretty much just running a instruction list.

Used a hash map for holding the functions as wanted to use real identifiers for the function names - adds to clarity. Also since we have pretty much all the code made already from the last project it seemed like a good proof of concept to use a version of it. 

Grammar for functions

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <RETURN> 

<SETFUNC> := "SETFUNC" <FUNCVAR> "{" <ARGSSET> "{" <INSTRUCTLIST>

<VARNUM> := number| <VAR> | <RUNFUNC>

<RETURN> := "RETURN" <VARNUM>

<ARGSSET> := <VAR><ARGSSET> | "}"

<RUNFUNC> := <FUNCVAR> "{" <ARGRUN>

<ARGRUN> := <VARNUM><ARGRUN> | "}"

<FUNCVAR> := Î£ n=50{a-z}

For FUNCVAR it can be any combination of lowercase letters up to a length of 50, sorry I didn't know how to say it properly with a formal grammar. Thought it would be a good idea to have them lowercase so they wouldn't interfere with any reserved words.

For ARGSET you cant reuse variables for arguments eg cant do myfunc { A A } so that means the max amount of args you can have is 26.

Additionally in the word struct for the extension I have added more features - added a pointer to parent that allows the function to use functions defined in the "main" bit of code. Cool thing about doing it this way is it sort of starts to build in scope as it will check for local functions first then go to main functions. This also means we can define functions within functions within functions etc - not that you would usually want to but I quite like having the option. I guess you could draw a parallel to this and overriding in object orientated programming where if a subclass has a function (method) with the same name as a superclass the subclass function (method) would take priority and override but its a bit different. 

When I run the function I create a deep copy of the function with its arguments then just run it like it was the main bit of the code- this means that I can run as many copies of the function as I want- therefore allowing for recursion.

I had to create different versions of the same functions in specific c files for the interpreter and for the extension as I wanted to be able to use return values of functions as varnums. I could have potentially included the struct for the outputs in the word_cont struct but was worried that having a struct in a struct in a struct etc for individual coordinates would make functions look sort of strange and bloated. I'm not sure if this was the right move though as we do pass in the word cont and the line cont to a lot of functions together.

One interesting thing I thought of when I was using functions in turtle code was that originally I thought that only testing for validity of the code when I set the func would be a disadvantage but it actually allows me to write the functions at the top of the file with the names of arrays I then define below which makes coding in turtle a bit more manageable. 



Thought control flow would be another thing that comes in handy when coding. At the moment we will just use varnums but if I ever bring this product to market we could eventually have reverse polish comparisons. Using the ANSI C grammar for inspiration - https://www.lysator.liu.se/c/ANSI-C-grammar-y.html .

Important thing to consider is that even if we don't execute statements we still want to check for syntax errors.

Formal grammar - 

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <FLOWSTATE>

<FLOWSTATE> := "IF" <EXPRESSION>  "{" <INSTRUCTLIST> | 
		"IF" <EXPRESSION>  "{" <INSTRUCTLIST> "ELSE" "{" <INSTRUCTLIST>

<COMPARATOR> := "==" "<" ">" ">=" "<=" 

<EXPRESSION> := <VARNUM> <COMPARATOR> <VARNUM>



Now lets do arrays. Eventually think it would be cool to read in files or something into them. Think then it would be quite useful. Thinking about what ADT would be best to implement it. Would seem like if we didn't want to worry about setting max sizes and stuff then a reallocing array could be cool - although maybe for flexibility a linked list could be best as it allows for easier removal and insertion within the array? Been looking at how lisp does its lists (https://softwareengineering.stackexchange.com/questions/91121/lisp-benefits-of-lists-as-code-over-arrays-as-code and http://www.eecs.qmul.ac.uk/~mmh/ADSOOF/linkedlists/Lecture9.pdf) for some inspiration as they use linked lists to implement arrays but probably will do stuff quite differently as I'm not going to need that much functionality and the syntax is a bit weird.
The only other thing that worries me is in for loops being able to change the value of the array but also use the array element as a stopping point for the loop. I was reading in java there's this thing that if you change a array while iterating over it it will lead to a error which seems like a good option, but In this case thought it would make sense to "freeze" the bounds of a loop so even if you change the bounds in the loop after initialising the loop it won't have weird effects. This way it works for functions as well to stop strange behaviour from going on. Also reduces the ways a user can create infinite loops which is probably a good thing.
Also going to make arrays global. 



 And then to store the various arrays we could use a hash map again. 
Formal Grammar -

<INSTRUCTION> ::= <FD> | <LT> |
<RT> | <DO> | <SET> | <SETFUNC> | <RUNFUNC> | <FLOWSTATE> | <INITARRAY> | <APPEND> | <REMOVEVAL> | <CHANGEVAL> | <FILETOARRAY> 

<INITARRAY> := "INITARR" <ARRAYIDENTIFIER> 

<APPEND>  := "APPEND" <ARRAYIDENTIFIER> <POLISH>


<CHANGEVAL> :=  "CHANGE" <ARRAYIDENTIFIER> "[" <VARNUM> "]" ":=" <POLISH>

<REMOVEVAL> := "DEL" <ARRAYIDENTIFIER> "[" <VARNUM> "]"

<ACCESSVAL> :=  <ARRAYIDENTIFIER> "[" <VARNUM> "]"

<VARNUM> := number| <VAR> | <RUNFUNC> | <ACCESSVAL> | <LEN>

<ARRAYIDENTIFIER> := starts with a_ then any set of lower case letters with 50 max total letters - eg a_myarr - this means that technically a_ is also valid

For accessing the arrays the VARNUM has to be positive and not a decimal. This is tested at the interpreting stage and not parsing stage so sometimes will slip through the cracks if for example its in a loop that has not executed. Would have liked to do it at parsing stage but cant tell what the return value of a function would be without actually running the function for instance.


<FILETOARRAY> := "LOAD" <ARRAYIDENTIFIER> filepath 

Filepath is the path from the executable file to the file you want to read in -was going to make it absolute but that would make it hard to move testing to other computers etc. 
Because we do not know what length arrays this could result in we need another instruction as well for it to be useful.

<LEN> "LEN" <ARRAYIDENTIFIER>


Just as I was finishing doing all of the above I realised it's actually super useful to start each instruction with a identifier like CHANGE or SET, the only one that I didn't start with an identifier is runfunc because it makes the code a lot more clunky to write I think. Especially as you can use runfunc pretty much anywhere like imagine in c having to do my_arr[RUNFUNC my_func(arg_list)] - its just quite long and makes it more cumbersome to write.


I finished the above and still got a bit of time so thought I'd try out making a debugger. Not sure where I will get with this but will try my best. The most challenging thing in this will be how to break down do loops. 

To start with I'm just going to create a debugger that deals with the main official grammar and then if I'm lucky and things go well I will proceed to my extension grammar as well.

Implemented a form of fuzzy matching to suggest commands when there is errors using Levenshtein_distance (https://en.wikipedia.org/wiki/Levenshtein_distance). Saw a version of it implemented in python that im just going to convert to c https://stackabuse.com/levenshtein-distance-and-text-similarity-in-python/. Although since most of the words are just two letters it isn't the perfect metric.

To start the debugger after compilation you enter path to debugger and a ttl file path.

For the commands you can do 

single step - moves forward one instruction
advance to error - advances to error or end of program
show code - shows the previous 5 lines of code and the next 5 lines of code
show coords - shows last 5 coordinates of where lines finished 
show pos - show word position that your on
show vars - shows values of variables
give suggestion - not that useful but tries to make a suggestion if there's an error in the command
set break - sets a break point in the program - unfortunately at the moment only one can be set at a time. Also if break point is in middle of instruction debugger will sometimes go slightly over break point. Also if breakpoint is set in a unexecuted loop program will run to end of the loop. Eg if we have a loop like DO A FROM 10 TO 4 it will just go to the first instruction outside of the loop.
del break - deletes break point
visualize - draws lines in sdl up to the current position
quit- quits the program

For commands like show coords it will only show a certain amount of digits so the string does not overflow. If it gets beyond a certain amount of digits it will look like 123... 







